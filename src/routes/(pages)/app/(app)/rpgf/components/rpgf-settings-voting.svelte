<script lang="ts">
  import FormField from '$lib/components/form-field/form-field.svelte';
  import { type ComponentProps } from 'svelte';
  import RpgfSettingsForm, { intitialSettingsState } from './rpgf-settings-form.svelte';
  import ListEditor from '$lib/components/list-editor/list-editor.svelte';
  import type { Items } from '$lib/components/list-editor/types';
  import ensureAtLeastOneArrayMember from '$lib/utils/ensure-at-least-one-array-member';
  import mapFilterUndefined from '$lib/utils/map-filter-undefined';
  import TextInput from '$lib/components/text-input/text-input.svelte';
  import type { TextInputValidationState } from '$lib/components/text-input/text-input';
  import AnnotationBox from '$lib/components/annotation-box/annotation-box.svelte';

  export let settingsFormProps: Omit<ComponentProps<RpgfSettingsForm>, 'updatedRoundOrDraft'>;
  $: isDraft = settingsFormProps.wrappedDraftOrRound.type === 'round-draft';

  let updatedRoundOrDraft = intitialSettingsState(settingsFormProps.wrappedDraftOrRound);

  // TODO(rpgf): use address driver account IDs as item keys, not addresses
  let voterItems: Items = Object.fromEntries(
    updatedRoundOrDraft.votingConfig?.allowedVoters.map((address) => {
      return [
        address,
        {
          type: 'address',
          address,
        },
      ];
    }) ?? [],
  );

  let votesPerVoter = updatedRoundOrDraft.votingConfig?.maxVotesPerVoter ?? undefined;

  let maxVotesPerProject =
    updatedRoundOrDraft.votingConfig?.maxVotesPerProjectPerVoter ?? undefined;

  $: addresses = mapFilterUndefined(
    Object.values(voterItems).map((item) => {
      if (item.type === 'address') {
        return item.address;
      } else {
        return undefined;
      }
    }),
    (v) => v,
  );

  let votesPerVoterValidationState: TextInputValidationState = { type: 'unvalidated' };
  $: {
    if (!votesPerVoter) {
      votesPerVoterValidationState = { type: 'unvalidated' };
    } else if (votesPerVoter < 1) {
      votesPerVoterValidationState = { type: 'invalid', message: 'Must be at least 1' };
    } else if (maxVotesPerProject && votesPerVoter < maxVotesPerProject) {
      votesPerVoterValidationState = {
        type: 'invalid',
        message: 'Must be equal or higher than max votes per project',
      };
    } else {
      votesPerVoterValidationState = { type: 'valid' };
    }
  }

  let maxVotesPerProjectValidationState: TextInputValidationState = { type: 'unvalidated' };
  $: {
    if (!maxVotesPerProject) {
      maxVotesPerProjectValidationState = { type: 'unvalidated' };
    } else if (maxVotesPerProject < 1) {
      maxVotesPerProjectValidationState = { type: 'invalid', message: 'Must be at least 1' };
    } else if (votesPerVoter && maxVotesPerProject > votesPerVoter) {
      maxVotesPerProjectValidationState = {
        type: 'invalid',
        message: 'Must be equal or lower than votes per voter',
      };
    } else {
      maxVotesPerProjectValidationState = { type: 'valid' };
    }
  }

  $: valid =
    Boolean(
      votesPerVoterValidationState.type === 'valid' &&
        maxVotesPerProjectValidationState.type === 'valid' &&
        ensureAtLeastOneArrayMember(addresses) &&
        votesPerVoter &&
        maxVotesPerProject,
    ) ||
    // If draft, allow deleting voting config
    (settingsFormProps.wrappedDraftOrRound.type === 'round-draft' &&
      votesPerVoterValidationState.type === 'unvalidated' &&
      maxVotesPerProjectValidationState.type === 'unvalidated' &&
      !addresses.length);

  $: {
    if (ensureAtLeastOneArrayMember(addresses) && votesPerVoter && maxVotesPerProject) {
      updatedRoundOrDraft = {
        ...updatedRoundOrDraft,
        votingConfig: {
          maxVotesPerVoter: Number(votesPerVoter),
          maxVotesPerProjectPerVoter: Number(maxVotesPerProject),
          allowedVoters: addresses,
        },
      };
    } else {
      updatedRoundOrDraft = {
        ...updatedRoundOrDraft,
        votingConfig: undefined,
      };
    }
  }

  $: wrappedDraftOrRound = settingsFormProps.wrappedDraftOrRound;

  // badgeholders can not be updated if voting is already over
  $: canUpdateBadgeholders =
    wrappedDraftOrRound.type === 'round-draft' ||
    !(
      wrappedDraftOrRound.round.state === 'pending-results' ||
      wrappedDraftOrRound.round.state === 'results'
    );
</script>

<RpgfSettingsForm {...settingsFormProps} bind:updatedRoundOrDraft invalid={!valid}>
  {#if !isDraft}
    <div style:align-self="flex-start">
      <AnnotationBox>
        You can no longer change the votes per voter or maximum votes per project for an ongoing,
        published round.
      </AnnotationBox>
    </div>
  {/if}

  <FormField title="Votes per voter*" disabled={!isDraft}>
    <TextInput
      placeholder="1000"
      validationState={votesPerVoterValidationState}
      bind:value={votesPerVoter}
      variant={{ type: 'number', min: 1 }}
    />
  </FormField>

  <FormField title="Maximum votes per project*" disabled={!isDraft}>
    <TextInput
      placeholder="100"
      validationState={maxVotesPerProjectValidationState}
      bind:value={maxVotesPerProject}
      variant={{ type: 'number', min: 1 }}
    />
  </FormField>

  <!-- TODO(rpgf): CSV Upload for badgeholders -->
  <FormField
    title="Badgeholders"
    description="These addresses will be able to vote in the round."
    disabled={!canUpdateBadgeholders}
  >
    <ListEditor
      bind:items={voterItems}
      allowDripLists={false}
      allowProjects={false}
      weightsMode={false}
    />
  </FormField>
</RpgfSettingsForm>
